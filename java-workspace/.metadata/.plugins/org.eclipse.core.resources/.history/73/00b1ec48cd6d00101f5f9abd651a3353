package com.kh.variable;

public class Casting {
	/*
	 * Type Casting(자료형 변환) : 자료형을 바꾸는 개념
	 * 
	 * ☆★☆★☆★☆★☆★☆★☆★☆★☆★ 매우 중요 ☆★☆★☆★☆★☆★☆★☆★☆★
	 * 
	 * 여러 분들이 과정 끝날떄까지 까먹으면 큰일나는 !!
	 * 자바에서 값을 처리하는 규칙
	 * 
	 * 1. = (대입연산자)를 기준으로 왼쪽 / 오른쪽이 같은 자료형이어야 한다.
	 * = > 같은 자료형에 해당하는 리터럴값만 대입할 수 있음
	 * = > 자료형이 다를 경우? == 값을 바꿔서 대입해야 함.
	 * 
	 * 2. 같은 자료형들끼리만 연산이 가능함.
	 * = > 자료형이 다른데 연산이 하고싶다?? 둘 중에 하나를 "형변환"해서 나머지 하나와 동일하게 맞춤
	 * 
	 * 
	 * 3. 연산의 결과물도 동일한 자료형이어야 한다.
	 * => 1 + 1 = 2(정수), 1.1 + 1.1 = 2.2(실수)
	 * 
	 * 
	 * [표현법] (바꾸고싶은자료형) 값
	 * 형변환연산자 / cast연산자
	 * 
	 * 현변환의 종류
	 * 
	 * 
	 * 1. 자동형변환(Promotion) : 자동으로 형변환이 진행됨
	 * - 작은 크기의 자료형 -> 큰 크기의 자료형 으로 바뀔 경우 자동형변환이 나타난다.		
	 * - 직접 형변환을 할 필요가 없음.
	 * 
	 * 2. 강제형변환(Type Casting) : 자동형변환이 이루어지지 않은 경우 진행
	 * - 직접 형변환을 해야할 때 => () 을 통해서 진행
	 * 
	 */
	
	/*
	 * byte  : 1Byte
	 * char  : 2Byte
	 * byte  : 1Byte
	 * short : 2Byte
	 * int   : 4Byte
	 * long  : 8Byte
	 * float : 4Byte
	 * double: 8Byte
	 */
	
	// 자동형변환(Promotion) : 작은 자료형 -> 큰 자료형
	public void autoCasting() {
		//System.out.println("이 내용을 콘솔창에 출력해보세요 실습 시작!");
		
		// 1. int(정수, 4Byte) => double(실수, 8Byte)
		// 변수 선언!과 동시에 초기화
		int intNum = 10;
		System.out.println(intNum);
		double doubleNum = (double)intNum; // 자료형을 앞에 자료형으로 바꿔준다 (사실 안 붙이지만 개념적으로 적음)
		System.out.println(doubleNum);
		
		// 2. int(정수, 4Byte)-> long(정수, 8Byte)
		int bigInteger = 120;
		long smallLong = /*(long)*/bigInteger;
		System.out.println(smallLong);
		
		System.out.println("================================");
		
		// 3. long(정수, 8Byte) => float(실수, 4Byte) ** 특이케이스
		long longNumber = 1000L;
		//int num = longNumber; 변환 안됨. 값 손실
										// promotion XXXXX
										// type casting / type conversion 000
		float floatNumber = longNumber; // 위 처럼 빨간줄이 나와야 정상인데 이건 안나옴 why? 아래 주석 확인
		System.out.println(floatNumber);
		// 정수가 실수로 변환될 때 큰사이즈의 정수 타입이 작은 사이즈 실수타입으로 형변환
		// 4Byte float형이 long형보다 표현할 수 있는 값의 범위가 더 넓기 때문
		
		// 정수는 1 2 3
		// 실수는 1.0000001, 1.0000002, 1.000 ~
		
		
		System.out.println("================================");
		
		// 4. char(2Byte) => int(4Byte) 
		char ch = 'a';
		System.out.println(ch);
		int num = ch;
		System.out.println(num);
		char ch2 = 97;
		System.out.println(ch2);
		
		System.out.println("================================");
		
		// 알송달송 퀴즈퀴즈
		System.out.println("퀴즈퀴즈시간!~");
		System.out.println('a');        // a
		System.out.println((int)'a');	// 97
		System.out.println('a' + 3);	// 100	
		System.out.println('a' + '3');	// 148
		System.out.println((int)'3');	// 51
		System.out.println('a' + "3");	// a3
		
		System.out.println("================================");
		System.out.println("퀴즈퀴즈시간!~");
		System.out.println('3');
		System.out.println((char)3);
		System.out.println((char)'3' + (char)3); // char + char 하면 연산 + 하면 무조건 정수로 된다.
		
		System.out.println("================================");
		System.out.println("퀴즈퀴즈시간!~");
		System.out.println(3);
		System.out.println('3');
		System.out.println("3");
		
		
		System.out.println("================================");
		// 번외. byte 또는 short형 간의 연산
		
		// -128 ~ 127
		/*byte byteNum = 128;
		System.out.println(byteNum); 4byte -> 1byte 오류*/
		byte byteNum = (byte)128;
		System.out.println(byteNum);
		
		byte b2 = 126;
		byte b3 = 3;
		/*System.out.println(b2 + b3);*/ // 말이 안됨. byte로 나올 수 있는 값이 아님. 그럼? int형
		// 결과 값은 int형 => 연산장치가 값을 처리하는 크기가 int형 크기 (4Byte) 즉,
		System.out.println((int)b2 + (int)b3);// 이렇게 바꿔서 변환해준다는 것 
		
		
		// 비교연산자( == )
		// 좌항과 우항의 값을 비교해서 결과값을 반환
		// true / false
		
		System.out.println("비교 연산자를 사용해보자~");
		System.out.println(1 == 2); 	// false
		System.out.println('a' == 'b'); // false
		System.out.println(2 == (int)'2'); // false  
		System.out.println((char)2 == '2'); // false 위 줄이랑 같음 50
		System.out.println((int)'2'); // 50
		System.out.println((int)'2' == '2'); // true
	}
	
	// 강제형변환(Type Casting) : 큰 크기의 자료형 => 작은 크기의 자료형
	public void forceCasting() {
		
		// 명시적 형변환이라고도 함
		// (바꿀자료형)값
		
		// double(8Byte) => int(4Byte)
		double doubleNum = 10.123123;
		int intNum = doubleNUM;
		
		System.out.println("rrr");
		
	}
}
